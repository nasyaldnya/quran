// --- DOM Elements ---
const languageSelect = document.getElementById('language-select');
const riwayaSelect = document.getElementById('riwaya-select');
const surahSelect = document.getElementById('surah-select');
const recitersList = document.getElementById('reciters-list');
const reciterDetails = document.getElementById('reciter-details');
const loader = document.getElementById('loader');
const detailsPlaceholder = document.getElementById('details-placeholder');
const searchReciterInput = document.getElementById('search-reciter-input');

// Player & Queue Elements
const playerContainer = document.getElementById('player-container');
const queuePanel = document.getElementById('queue-panel');
const queueHandle = document.getElementById('queue-handle');
const toggleQueueBtn = document.getElementById('toggle-queue-btn');
const queueList = document.getElementById('queue-list');
const queuePlaceholder = document.getElementById('queue-placeholder');
const audioPlayer = document.getElementById('audio-player');
const nowPlaying = document.getElementById('now-playing');
const playPauseBtn = document.getElementById('play-pause-btn');
const playIcon = document.getElementById('play-icon');
const pauseIcon = document.getElementById('pause-icon');
const nextBtn = document.getElementById('next-btn');
const prevBtn = document.getElementById('prev-btn');
const progressBarContainer = document.getElementById('progress-bar-container');
const progressBar = document.getElementById('progress-bar');
const currentTimeEl = document.getElementById('current-time');
const totalDurationEl = document.getElementById('total-duration');
const playbackSpeed = document.getElementById('playback-speed');
const sleepTimerBtns = document.querySelectorAll('.sleep-timer-btn');
const sleepTimerDisplay = document.getElementById('sleep-timer-display');
const cancelSleepTimerBtn = document.getElementById('cancel-sleep-timer-btn');
const copyLinkBtn = document.getElementById('copy-link-btn');
const downloadBtn = document.getElementById('download-btn');
const shuffleBtnPlayer = document.getElementById('shuffle-btn-player');
const repeatBtn = document.getElementById('repeat-btn');
const themeToggleBtn = document.getElementById('theme-toggle');

// Visualizer
const visualizerCanvas = document.getElementById('visualizer');
const canvasCtx = visualizerCanvas.getContext('2d');
let audioCtx;
let analyser;
let source;
let dataArray;
let bufferLength;

// --- API Base URL ---
const API_BASE_URL = 'https://mp3quran.net/api/v3';

// --- State ---
let allSurahs = [];
let allReciters = [];
let favorites = [];
let queue = [];
let currentQueueIndex = -1;
let sleepTimerId = null;
let sleepIntervalId = null;
let isShuffled = false;
let repeatMode = 'off'; // 'off', 'one', 'all'
let currentFetchCtrl;
const collator = new Intl.Collator('ar', { sensitivity: 'base', numeric: true });

// --- Assets ---
const makkiIcon = `<span title="Ø³ÙˆØ±Ø© Ù…ÙƒÙŠØ©">ğŸ•‹</span>`;
const madaniIcon = `<span title="Ø³ÙˆØ±Ø© Ù…Ø¯Ù†ÙŠØ©">ğŸ•Œ</span>`;
const playingIcon = `<svg class="w-4 h-4 text-primary animate-pulse" viewBox="0 0 24 24" fill="currentColor" xmlns="http://www.w3.org/2000/svg"><path d="M6 7H4V17H6V7ZM10 4H8V20H10V4ZM14 10H12V14H14V10ZM18 7H16V17H18V7Z"/></svg>`;


// --- Helper Functions ---
const showToast = (message, type = 'success') => {
    const toastContainer = document.getElementById('toast-container');
    const toast = document.createElement('div');
    let bgColor = 'bg-green-500';
    if (type === 'warning') bgColor = 'bg-yellow-500';
    if (type === 'error') bgColor = 'bg-red-500';
    
    toast.className = `p-3 rounded-lg text-white shadow-lg animate-toast`;
    toast.classList.add(bgColor);
    toast.textContent = message;

    toastContainer.appendChild(toast);
    setTimeout(() => {
        toast.remove();
    }, 3000);
};

const fetchData = async (endpoint, signal) => {
    try {
        const response = await fetch(`${API_BASE_URL}/${endpoint}`, { signal });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        return await response.json();
    } catch (error) {
        if (error.name === 'AbortError') {
            // This is expected, so we can ignore it.
            return null;
        }
        console.error("Failed to fetch data:", error);
        recitersList.innerHTML = `<p class="text-center text-red-500">Ø­Ø¯Ø« Ø®Ø·Ø£ Ø£Ø«Ù†Ø§Ø¡ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª.</p>`;
        return null;
    }
};

const padSurahNumber = (number) => String(number).padStart(3, '0');
const formatTime = (seconds) => {
    if (isNaN(seconds)) return '00:00';
    const minutes = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
};
const showLoader = (show) => {
    loader.style.display = show ? 'flex' : 'none';
    if (show) recitersList.innerHTML = '';
};

const normalizeArabic = (str) => {
    if (!str) return '';
    return str
        .toLowerCase()
        .replace(/[Ø£Ø¥Ø¢Ø§]/g, 'Ø§')
        .replace(/Ù‰/g, 'ÙŠ')
        .replace(/Ø©/g, 'Ù‡')
        .replace(/[^\u0600-\u06FF\s\d]/g, '');
};

const debounce = (fn, ms = 200) => {
    let t;
    return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), ms);
    };
};

const withSlash = (u) => (u.endsWith('/') ? u : `${u}/`);

// --- Favorites Logic ---
const loadFavorites = () => {
    favorites = JSON.parse(localStorage.getItem('quranPlayerFavorites')) || [];
};
const saveFavorites = () => {
    localStorage.setItem('quranPlayerFavorites', JSON.stringify(favorites));
};
const toggleFavorite = (event, reciterId) => {
    event.stopPropagation();
    const star = event.currentTarget;
    if (favorites.includes(reciterId)) {
        favorites = favorites.filter(id => id !== reciterId);
        star.classList.remove('favorited');
        star.innerHTML = 'â˜†';
    } else {
        favorites.push(reciterId);
        star.classList.add('favorited');
        star.innerHTML = 'â˜…';
    }
    saveFavorites();
    renderReciters();
};

// --- Rendering Functions ---
const renderLanguages = (data) => {
    if (!data || !data.language) return;
    const currentLang = localStorage.getItem('quranLang') || languageSelect.value || 'ar';
    languageSelect.innerHTML = '';
    data.language.forEach(lang => {
        const val = getLanguageCode(lang.surah) || 'ar';
        const opt = document.createElement('option');
        opt.value = val;
        opt.textContent = lang.native;
        if (val === currentLang) opt.selected = true;
        languageSelect.appendChild(opt);
    });
};
const getLanguageCode = (url) => {
    try { 
        return new URL(url).searchParams.get('language');
    } catch(e) {
        console.error("Could not parse URL for language code:", url, e);
        return 'ar';
    }
};

const renderRiwayat = (data) => {
    if (!data || !data.riwayat) return;
    riwayaSelect.innerHTML = '<option value="">ÙƒÙ„ Ø§Ù„Ø±ÙˆØ§ÙŠØ§Øª</option>';
    data.riwayat.forEach(riwaya => {
        const option = document.createElement('option');
        option.value = riwaya.id;
        option.textContent = riwaya.name;
        riwayaSelect.appendChild(option);
    });
};

const renderSurahs = (data) => {
    if (!data || !data.suwar) return;
    allSurahs = data.suwar;
    surahSelect.innerHTML = '<option value="">ÙƒÙ„ Ø§Ù„Ø³ÙˆØ±</option>';
    allSurahs.forEach(surah => {
        const option = document.createElement('option');
        option.value = surah.id;
        option.textContent = `${surah.id}. ${surah.name}`;
        surahSelect.appendChild(option);
    });
};

const renderReciters = () => {
    recitersList.innerHTML = '';
    const searchTerm = normalizeArabic(searchReciterInput.value.trim());
    let filteredReciters = allReciters.filter(reciter => 
        normalizeArabic(reciter.name).includes(searchTerm)
    );

    filteredReciters.sort((a, b) => {
        const aIsFav = favorites.includes(a.id);
        const bIsFav = favorites.includes(b.id);
        if (aIsFav && !bIsFav) return -1;
        if (!aIsFav && bIsFav) return 1;
        return collator.compare(a.name, b.name); 
    });

    if (filteredReciters.length === 0) {
        recitersList.innerHTML = `<p class="text-center text-gray-500 p-4">Ù„Ù… ÙŠØªÙ… Ø§Ù„Ø¹Ø«ÙˆØ± Ø¹Ù„Ù‰ Ù‚Ø±Ø§Ø¡.</p>`;
        return;
    }

    filteredReciters.forEach(reciter => {
        const isFav = favorites.includes(reciter.id);
        const reciterCard = document.createElement('div');
        reciterCard.className = 'flex items-center justify-between w-full text-right p-3 rounded-lg hover:bg-gray-200/50 dark:hover:bg-gray-700/50 cursor-pointer transition-colors duration-200';
        reciterCard.innerHTML = `
            <span>${reciter.name}</span>
            <button aria-label="Ø¥Ø¶Ø§ÙØ© Ù„Ù„Ù…ÙØ¶Ù„Ø©" class="favorite-star text-2xl text-gray-300 hover:text-amber-400 ${isFav ? 'favorited' : ''}">
                ${isFav ? 'â˜…' : 'â˜†'}
            </button>
        `;
        reciterCard.querySelector('.favorite-star').onclick = (e) => toggleFavorite(e, reciter.id);
        reciterCard.onclick = () => {
            renderReciterDetails(reciter);
            document.querySelectorAll('#reciters-list > div').forEach(child => child.classList.remove('bg-teal-100', 'dark:bg-teal-900'));
            reciterCard.classList.add('bg-teal-100', 'dark:bg-teal-900');
        };
        recitersList.appendChild(reciterCard);
    });
};

const renderReciterDetails = (reciter) => {
    if (detailsPlaceholder) detailsPlaceholder.style.display = 'none';
    reciterDetails.innerHTML = `
        <h3 class="text-2xl font-bold mb-4 text-primary">${reciter.name}</h3>
        <div class="space-y-4">
            ${reciter.moshaf.map((moshaf, index) => `
                <div class="bg-secondary p-3 rounded-lg">
                    <div class="flex flex-wrap gap-2 justify-between items-center mb-3">
                        <h4 class="font-semibold">${moshaf.name}</h4>
                        <div class="flex items-center gap-2">
                             <button aria-label="Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙ„ Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©" data-moshaf-index-add="${index}" class="add-all-btn text-xs bg-blue-500 text-white px-3 py-1 rounded-full hover:bg-blue-600">Ø¥Ø¶Ø§ÙØ© Ø§Ù„ÙƒÙ„</button>
                             <button aria-label="ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒÙ„ ÙˆØ§Ø³ØªØ¨Ø¯Ø§Ù„ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©" data-moshaf-index-play="${index}" class="play-all-btn text-xs bg-primary text-white px-3 py-1 rounded-full hover:bg-primary-hover">ØªØ´ØºÙŠÙ„ Ø§Ù„ÙƒÙ„</button>
                        </div>
                    </div>
                     <div class="mb-3">
                         <input type="search" id="search-surah-input-${index}" placeholder="Ø§Ø¨Ø­Ø« Ø¹Ù† Ø³ÙˆØ±Ø©..." class="bg-card border border-custom text-sm rounded-lg focus:ring-teal-500 focus:border-teal-500 block w-full p-2.5">
                     </div>
                    <div class="text-xs text-gray-500 dark:text-gray-400 flex items-center gap-4 mb-3 px-1">
                        <span>Ù…ÙØªØ§Ø­ Ø§Ù„Ø±Ù…ÙˆØ²:</span>
                        <span class="flex items-center gap-1">ğŸ•‹ Ø³ÙˆØ±Ø© Ù…ÙƒÙŠØ©</span>
                        <span class="flex items-center gap-1">ğŸ•Œ Ø³ÙˆØ±Ø© Ù…Ø¯Ù†ÙŠØ©</span>
                    </div>
                    <div id="surah-list-${index}" class="mt-3 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-3 gap-2 max-h-96 overflow-y-auto p-1"></div>
                </div>
            `).join('')}
        </div>`;

    reciter.moshaf.forEach((moshaf, index) => {
        const surahListContainer = document.getElementById(`surah-list-${index}`);
        const availableIds = new Set(moshaf.surah_list.split(','));
        const surahsToRender = allSurahs.filter(s => s && availableIds.has(String(s.id)));

        surahsToRender.forEach(surah => {
            const surahItem = document.createElement('div');
            const icon = surah.makkia === 1 ? makkiIcon : madaniIcon;

            surahItem.id = `surah-item-${moshaf.id}-${surah.id}`;
            surahItem.className = `p-2 text-sm rounded-md transition-all duration-200 flex items-center justify-between gap-2 bg-card shadow-sm border border-custom`;
            
            surahItem.innerHTML = `
                <button aria-label="ØªØ´ØºÙŠÙ„ Ø³ÙˆØ±Ø© ${surah.name}" class="play-surah-btn flex-grow text-right flex items-center gap-2 overflow-hidden cursor-pointer">
                    ${icon}
                    <span class="truncate">${surah.name}</span>
                </button>
                <button aria-label="Ø¥Ø¶Ø§ÙØ© Ø³ÙˆØ±Ø© ${surah.name} Ù„Ù„Ù‚Ø§Ø¦Ù…Ø©" class="add-to-queue-btn p-1 rounded-full hover:bg-teal-100 dark:hover:bg-teal-900 cursor-pointer">
                    <svg class="w-5 h-5 text-primary" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 4.5v15m7.5-7.5h-15" /></svg>
                </button>
            `;
            
            surahItem.querySelector('.play-surah-btn').onclick = () => {
                queue = [{ reciter, moshaf, surah }];
                currentQueueIndex = 0;
                playFromQueue();
            };
            surahItem.querySelector('.add-to-queue-btn').onclick = () => {
                addTrackToQueue({ reciter, moshaf, surah }, false)
            };
            surahListContainer.appendChild(surahItem);
        });

        reciterDetails.querySelector(`[data-moshaf-index-play="${index}"]`).onclick = () => handlePlayAll(reciter, moshaf, true);
        reciterDetails.querySelector(`[data-moshaf-index-add="${index}"]`).onclick = () => handlePlayAll(reciter, moshaf, false);

        reciterDetails.querySelector(`#search-surah-input-${index}`).addEventListener('input', (e) => {
            const searchTerm = normalizeArabic(e.target.value.trim());
            const items = surahListContainer.querySelectorAll('div');
            items.forEach(item => {
                const surahName = normalizeArabic(item.querySelector('span.truncate').textContent);
                if (surahName.includes(searchTerm)) item.classList.remove('hidden');
                else item.classList.add('hidden');
            });
        });
    });
    if (window.innerWidth < 1024) reciterDetails.scrollIntoView({ behavior: 'smooth' });
};

let draggedItem = null;

const renderQueue = () => {
    queueList.innerHTML = '';
    if (queue.length === 0) {
        queuePlaceholder.classList.remove('hidden');
        return;
    }
    queuePlaceholder.classList.add('hidden');

    queue.forEach((track, index) => {
        const item = document.createElement('div');
        item.className = `queue-item flex items-center justify-between p-2 rounded-lg cursor-pointer hover:bg-gray-200/50 dark:hover:bg-gray-700/50`;
        item.draggable = true;
        item.dataset.index = index;
        item.setAttribute('role','button');
        item.setAttribute('tabindex','0');

        const isPlaying = index === currentQueueIndex;
         if (isPlaying) {
            item.classList.add('queue-item-playing');
        }

        item.innerHTML = `
            <div class="flex items-center gap-2 overflow-hidden">
                <span class="drag-handle text-gray-400 cursor-grab flex-shrink-0">${isPlaying ? playingIcon : `<svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"></path></svg>`}</span>
                <div class="flex-grow overflow-hidden">
                    <p class="font-semibold truncate text-sm">${track.surah.name}</p>
                    <p class="text-xs text-gray-500 dark:text-gray-400 truncate">${track.reciter.name}</p>
                </div>
            </div>
            <button aria-label="Ø¥Ø²Ø§Ù„Ø© Ù…Ù† Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©" class="remove-from-queue-btn p-1 rounded-full hover:bg-red-100 dark:hover:bg-red-900/50 flex-shrink-0">
                <svg class="w-4 h-4 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
            </button>
        `;
        
        item.addEventListener('click', (e) => {
            if (!e.target.closest('.remove-from-queue-btn') && !e.target.closest('.drag-handle')) {
               playTrackAtIndex(index);
            }
        });
        
        item.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                playTrackAtIndex(index);
            }
        });

        item.querySelector('.remove-from-queue-btn').addEventListener('click', () => removeFromQueue(index));

        // Touch Drag & Drop
        item.addEventListener('touchstart', (e) => {
            draggedItem = item;
            setTimeout(() => item.classList.add('dragging'), 0);
        });

        item.addEventListener('touchmove', e => {
            e.preventDefault();
            const touchLocation = e.targetTouches[0];
            const target = document.elementFromPoint(touchLocation.pageX, touchLocation.pageY)?.closest('.queue-item');
             if (target && draggedItem && target !== draggedItem) {
                const rect = target.getBoundingClientRect();
                const offset = touchLocation.clientY - rect.top - rect.height / 2;
                if (offset < 0) {
                    queueList.insertBefore(draggedItem, target);
                } else {
                    queueList.insertBefore(draggedItem, target.nextSibling);
                }
            }
        });

        item.addEventListener('touchend', () => {
            if(!draggedItem) return;
            draggedItem.classList.remove('dragging');
            draggedItem = null;
            const event = new Event('drop');
            queueList.dispatchEvent(event);
        });

        // Mouse Drag & Drop
        item.addEventListener('dragstart', (e) => {
            draggedItem = item;
            setTimeout(() => item.classList.add('dragging'), 0);
        });

        item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            draggedItem = null;
        });
        
        item.addEventListener('dragover', e => {
            e.preventDefault();
            const target = e.target.closest('.queue-item');
            if (target && draggedItem && target !== draggedItem) {
                const rect = target.getBoundingClientRect();
                const offset = e.clientY - rect.top - rect.height / 2;
                if (offset < 0) {
                    queueList.insertBefore(draggedItem, target);
                } else {
                    queueList.insertBefore(draggedItem, target.nextSibling);
                }
            }
        });

        queueList.appendChild(item);
    });
};

// --- Queue & Core Logic ---
const addTrackToQueue = (track, playNow = false) => {
    const isDuplicate = queue.some(item =>
        item.surah.id === track.surah.id &&
        item.reciter.id === track.reciter.id &&
        item.moshaf.id === track.moshaf.id
    );

    if (isDuplicate) {
        showToast("Ø§Ù„Ø³ÙˆØ±Ø© Ù…ÙˆØ¬ÙˆØ¯Ø© Ø¨Ø§Ù„ÙØ¹Ù„ ÙÙŠ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„ØªØ´ØºÙŠÙ„.", 'warning');
        return;
    }

    queue.push(track);
    showToast("ØªÙ…Øª Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ø³ÙˆØ±Ø© Ø¨Ù†Ø¬Ø§Ø­.");
    
    if (playNow) {
        currentQueueIndex = queue.length - 1;
        playFromQueue();
    }
    renderQueue();
};

const handlePlayAll = (reciter, moshaf, replaceQueue) => {
    if (replaceQueue) {
        queue = [];
        currentQueueIndex = -1;
    }
    const availableIds = new Set(moshaf.surah_list.split(','));
    const surahsToAdd = allSurahs.filter(s => s && availableIds.has(String(s.id)));

    surahsToAdd.forEach(surah => queue.push({ reciter, moshaf, surah }));
    
    if(replaceQueue && queue.length > 0) {
        currentQueueIndex = 0;
        playFromQueue();
    }
    renderQueue();
};

const removeFromQueue = (index) => {
    const wasPlaying = index === currentQueueIndex;
    queue.splice(index, 1);
    if(wasPlaying) {
        if(queue.length === 0) {
            audioPlayer.pause();
            audioPlayer.src = '';
            currentQueueIndex = -1;
             nowPlaying.innerHTML = `
                <p class="font-bold text-primary truncate">Ù„Ù… ÙŠØªÙ… ØªØ­Ø¯ÙŠØ¯ Ø£ÙŠ Ù…Ù‚Ø·Ø¹</p>
                <p class="text-sm text-gray-600 dark:text-gray-400 truncate">-</p>
            `;
        } else if (currentQueueIndex >= queue.length) {
            currentQueueIndex = 0;
            playFromQueue();
        } else {
            playFromQueue();
        }
    } else if (index < currentQueueIndex) {
        currentQueueIndex--;
    }
    renderQueue();
};

const playTrackAtIndex = (index) => {
    currentQueueIndex = index;
    playFromQueue();
}

const playFromQueue = () => {
    if (currentQueueIndex < 0 || currentQueueIndex >= queue.length) {
         updatePlayerUI(false);
         return;
    }
    const { reciter, moshaf, surah } = queue[currentQueueIndex];
    const surahNumber = padSurahNumber(surah.id);
    const audioSrc = `${withSlash(moshaf.server)}${surahNumber}.mp3`;
    
    audioPlayer.src = audioSrc;
    audioPlayer.play().catch(e => console.error("Playback failed:", e));

    nowPlaying.innerHTML = `
        <p class="font-bold text-primary truncate" title="${surah.name}">${surah.name}</p>
        <p class="text-sm text-gray-600 dark:text-gray-400 truncate" title="${reciter.name} - ${moshaf.name}">${reciter.name} - ${moshaf.name}</p>
    `;
    playerContainer.style.transform = 'translateY(0)';

    document.querySelectorAll('[id^=surah-item-]').forEach(btn => btn.classList.remove('playing'));
    const currentItem = document.getElementById(`surah-item-${moshaf.id}-${surah.id}`);
    if(currentItem) currentItem.classList.add('playing');
    renderQueue();
    updateShareURL();
};

const onTrackEnded = () => {
    if (repeatMode === 'one') {
        audioPlayer.currentTime = 0;
        audioPlayer.play();
    } else if (currentQueueIndex < queue.length - 1) {
        playNext();
    } else if (repeatMode === 'all') {
        currentQueueIndex = 0;
        playFromQueue();
    } else {
        updatePlayerUI(false);
    }
};

const playNext = () => {
    if (currentQueueIndex < queue.length - 1) {
        currentQueueIndex++;
        playFromQueue();
    } else if (repeatMode === 'all' && queue.length > 0) {
        currentQueueIndex = 0;
        playFromQueue();
    }
};
const playPrev = () => {
    if (currentQueueIndex > 0) {
        currentQueueIndex--;
        playFromQueue();
    }
};

// --- Player UI & Controls ---
const updatePlayerUI = (isPlaying) => {
    playPauseBtn.setAttribute('aria-label', isPlaying ? 'Ø¥ÙŠÙ‚Ø§Ù' : 'ØªØ´ØºÙŠÙ„');
    if (isPlaying) {
        playIcon.classList.add('hidden');
        pauseIcon.classList.remove('hidden');
    } else {
        playIcon.classList.remove('hidden');
        pauseIcon.classList.add('hidden');
    }
    nextBtn.disabled = currentQueueIndex >= queue.length - 1 && repeatMode !== 'all';
    prevBtn.disabled = currentQueueIndex <= 0;
    copyLinkBtn.disabled = !audioPlayer.src;
    downloadBtn.disabled = !audioPlayer.src;
};

const updateProgress = () => {
    const dur = audioPlayer.duration || 0;
    const cur = audioPlayer.currentTime || 0;
    const progressPercent = dur ? (cur / dur) * 100 : 0;
    progressBar.style.width = `${progressPercent}%`;
    currentTimeEl.textContent = formatTime(cur);
    totalDurationEl.textContent = formatTime(dur);
    progressBarContainer.setAttribute('aria-valuenow', String(progressPercent.toFixed(0)));
};

const toggleShuffle = () => {
    isShuffled = !isShuffled;
    shuffleBtnPlayer.classList.toggle('text-primary', isShuffled);
    shuffleBtnPlayer.setAttribute('aria-pressed', String(isShuffled));

    if(isShuffled && queue.length > 1) {
        const currentTrack = queue[currentQueueIndex];
        for (let i = queue.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [queue[i], queue[j]] = [queue[j], queue[i]];
        }
        const newIndexOfCurrent = queue.indexOf(currentTrack);
        if(newIndexOfCurrent !== -1) {
            [queue[0], queue[newIndexOfCurrent]] = [queue[newIndexOfCurrent], queue[0]];
            currentQueueIndex = 0;
        }
    }
    renderQueue();
};

const cycleRepeatMode = () => {
    if (repeatMode === 'off') {
        repeatMode = 'all';
        repeatBtn.classList.add('text-primary');
        repeatBtn.textContent = 'ØªÙƒØ±Ø§Ø± Ø§Ù„ÙƒÙ„';
    } else if (repeatMode === 'all') {
        repeatMode = 'one';
        repeatBtn.textContent = 'ØªÙƒØ±Ø§Ø± 1';
    } else {
        repeatMode = 'off';
        repeatBtn.classList.remove('text-primary');
        repeatBtn.textContent = 'ØªÙƒØ±Ø§Ø±';
    }
    repeatBtn.setAttribute('aria-pressed', String(repeatMode !== 'off'));
    updatePlayerUI(audioPlayer.paused === false);
};

const seek = (e) => {
    const rect = progressBarContainer.getBoundingClientRect();
    const clickX = rect.right - e.clientX;
    const width = rect.width;
    audioPlayer.currentTime = (clickX / width) * audioPlayer.duration;
};

const toggleQueuePanel = () => {
    playerContainer.classList.toggle('queue-open');
};

playPauseBtn.addEventListener('click', () => {
    if (audioPlayer.src) {
        if (audioPlayer.paused) audioPlayer.play();
        else audioPlayer.pause();
    } else if (queue.length > 0) {
        currentQueueIndex = 0;
        playFromQueue();
    }
});

audioPlayer.addEventListener('play', () => updatePlayerUI(true));
audioPlayer.addEventListener('pause', () => updatePlayerUI(false));
audioPlayer.addEventListener('ended', onTrackEnded);
audioPlayer.addEventListener('timeupdate', updateProgress);
audioPlayer.addEventListener('loadedmetadata', updateProgress);

nextBtn.addEventListener('click', playNext);
prevBtn.addEventListener('click', playPrev);
progressBarContainer.addEventListener('click', seek);
playbackSpeed.addEventListener('change', (e) => audioPlayer.playbackRate = e.target.value);
shuffleBtnPlayer.addEventListener('click', toggleShuffle);
repeatBtn.addEventListener('click', cycleRepeatMode);
toggleQueueBtn.addEventListener('click', toggleQueuePanel);
queueHandle.addEventListener('click', toggleQueuePanel);

queueList.addEventListener('drop', () => {
    const currentTrack = queue[currentQueueIndex];
    const newOrder = [...queueList.querySelectorAll('.queue-item')].map(item => queue[item.dataset.index]);
    queue = newOrder;
    currentQueueIndex = queue.indexOf(currentTrack);
    renderQueue();
});


// --- Sleep Timer Logic ---
const setSleepTimer = (minutes) => {
    clearTimeout(sleepTimerId);
    clearInterval(sleepIntervalId);

    const endTime = Date.now() + minutes * 60 * 1000;
    sleepTimerId = setTimeout(() => {
        audioPlayer.pause();
        cancelSleepTimer();
    }, minutes * 60 * 1000);

    const updateTimerDisplay = () => {
         const remaining = Math.round((endTime - Date.now()) / 1000);
        if (remaining <= 0) {
            cancelSleepTimer();
        } else {
            sleepTimerDisplay.textContent = formatTime(remaining);
        }
    }
    updateTimerDisplay();
    sleepIntervalId = setInterval(updateTimerDisplay, 1000);
    
    cancelSleepTimerBtn.classList.remove('hidden');
};

const cancelSleepTimer = () => {
    clearTimeout(sleepTimerId);
    clearInterval(sleepIntervalId);
    sleepTimerId = null;
    sleepIntervalId = null;
    sleepTimerDisplay.textContent = '';
    cancelSleepTimerBtn.classList.add('hidden');
};

sleepTimerBtns.forEach(btn => btn.addEventListener('click', () => setSleepTimer(btn.dataset.time)));
cancelSleepTimerBtn.addEventListener('click', cancelSleepTimer);

// --- Copy/Download Logic ---
const safeDownload = async (url, filename) => {
    try {
        const res = await fetch(url, { mode: 'cors' });
        if (!res.ok) throw new Error('Bad response status');
        const blob = await res.blob();
        const obj = URL.createObjectURL(blob);
        const a = Object.assign(document.createElement('a'), { href: obj, download: filename });
        document.body.appendChild(a); a.click(); a.remove(); URL.revokeObjectURL(obj);
    } catch {
        showToast('ØªØ¹Ø°Ø± Ø§Ù„ØªÙ†Ø²ÙŠÙ„ (Ù‚ÙŠÙˆØ¯ Ø§Ù„Ø®Ø§Ø¯Ù…). Ø§Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· ÙˆØ­Ù…Ù‘Ù„Ù‡ ÙŠØ¯ÙˆÙŠÙ‹Ø§.', 'error');
    }
};
copyLinkBtn.addEventListener('click', () => {
    navigator.clipboard.writeText(audioPlayer.src).then(() => {
        showToast('ØªÙ… Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø·');
    });
});
downloadBtn.addEventListener('click', () => {
    const t = queue[currentQueueIndex]; if (!t) return;
    safeDownload(audioPlayer.src, `${t.reciter.name} - ${t.surah.name}.mp3`);
});

// --- Ripple Effect (Event Delegation) ---
document.addEventListener('click', function(e) {
    const button = e.target.closest('.relative.overflow-hidden');
    if (!button) return;

    const ripple = document.createElement('span');
    const rect = button.getBoundingClientRect();
    const size = Math.max(rect.width, rect.height);
    const x = e.clientX - rect.left - size / 2;
    const y = e.clientY - rect.top - size / 2;
    
    ripple.style.width = ripple.style.height = `${size}px`;
    ripple.style.left = `${x}px`;
    ripple.style.top = `${y}px`;
    ripple.classList.add('ripple');
    
    const existingRipple = button.querySelector('.ripple');
    if(existingRipple) existingRipple.remove();
    
    button.appendChild(ripple);
});

// --- Theme Toggle ---
const applyTheme = () => {
     if (localStorage.getItem('color-theme') === 'dark' || (!('color-theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
        document.documentElement.classList.add('dark');
    } else {
        document.documentElement.classList.remove('dark');
    }
};

themeToggleBtn.addEventListener('click', () => {
    document.documentElement.classList.toggle('dark');
    if (document.documentElement.classList.contains('dark')) {
        localStorage.setItem('color-theme', 'dark');
    } else {
        localStorage.setItem('color-theme', 'light');
    }
});

// --- Audio Visualizer ---
const setupAudioContext = () => {
    if(audioCtx) return;
    try {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        analyser = audioCtx.createAnalyser();
        source = audioCtx.createMediaElementSource(audioPlayer);
        source.connect(analyser);
        analyser.connect(audioCtx.destination);
        
        analyser.fftSize = 128;
        bufferLength = analyser.frequencyBinCount;
        dataArray = new Uint8Array(bufferLength);
        visualizerCanvas.classList.remove('hidden');
        drawVisualizer();
    } catch (e) {
        console.error("Web Audio API is not supported by this browser.", e);
    }
};

const drawVisualizer = () => {
    requestAnimationFrame(drawVisualizer);
    if (!analyser) return;

    analyser.getByteFrequencyData(dataArray);
    
    canvasCtx.clearRect(0, 0, visualizerCanvas.width, visualizerCanvas.height);
    
    const barWidth = (visualizerCanvas.width / bufferLength) * 1.5;
    let barHeight;
    let x = 0;
    const isDark = document.documentElement.classList.contains('dark');
    const color = isDark ? '#2dd4bf' : '#0d9488';

    for(let i = 0; i < bufferLength; i++) {
        barHeight = dataArray[i] / 3;
        canvasCtx.fillStyle = color;
        canvasCtx.fillRect(x, visualizerCanvas.height - barHeight, barWidth, barHeight);
        x += barWidth + 1;
    }
};

audioPlayer.addEventListener('play', setupAudioContext);

// --- Keyboard Shortcuts ---
document.addEventListener('keydown', (e) => {
    if(e.target.tagName === 'INPUT') return;
    switch (e.code) {
        case 'Space': e.preventDefault(); playPauseBtn.click(); break;
        case 'ArrowRight': e.preventDefault(); playNext(); break;
        case 'ArrowLeft': e.preventDefault(); playPrev(); break;
    }
});

// --- Media Session API ---
if ('mediaSession' in navigator) {
    const updateMediaSession = () => {
        const track = queue[currentQueueIndex];
        if (!track) return;
        navigator.mediaSession.metadata = new MediaMetadata({
            title: track.surah.name,
            artist: track.reciter.name,
            album: track.moshaf.name,
        });
    };

    audioPlayer.addEventListener('play', updateMediaSession);
    navigator.mediaSession.setActionHandler('play', () => audioPlayer.play());
    navigator.mediaSession.setActionHandler('pause', () => audioPlayer.pause());
    navigator.mediaSession.setActionHandler('previoustrack', playPrev);
    navigator.mediaSession.setActionHandler('nexttrack', playNext);
}

// --- Deep Linking ---
const applyDeepLink = () => {
    const params = new URLSearchParams(location.search);
    const rid = params.get('reciter'), mid = params.get('moshaf'), sid = params.get('surah');
    if (!rid || !mid || !sid || !allReciters.length || !allSurahs.length) return;
    
    const reciter = allReciters.find(r => String(r.id) === String(rid));
    if (!reciter) return;
    
    const moshaf = reciter.moshaf.find(m => String(m.id) === String(mid));
    if (!moshaf) return;
    
    const surah = allSurahs.find(s => String(s.id) === String(sid));
    if (!surah) return;
    
    queue = [{ reciter, moshaf, surah }];
    currentQueueIndex = 0;
    playFromQueue();
};

const updateShareURL = () => {
    try {
        const track = queue[currentQueueIndex];
        if (!track) return;
        const params = new URLSearchParams({
            reciter: track.reciter.id,
            moshaf: track.moshaf.id,
            surah: track.surah.id
        });
        const path = location.pathname.includes('blob:') ? '' : location.pathname;
        history.replaceState(null, '', `${path}?${params.toString()}`);
    } catch (error) {
        if (error.name === 'SecurityError') {
            console.warn('History API is not accessible in this environment. Deep linking will be affected.');
        } else {
            console.error('Failed to update share URL:', error);
        }
    }
};
audioPlayer.addEventListener('play', updateShareURL);


// --- State Persistence ---
const saveState = () => {
    if (!queue.length) {
        localStorage.removeItem('quranPlayerState');
        return;
    };
    const state = {
        queue,
        currentQueueIndex,
        repeatMode,
        isShuffled,
        speed: audioPlayer.playbackRate,
        currentTime: audioPlayer.currentTime
    };
    localStorage.setItem('quranPlayerState', JSON.stringify(state));
};

const loadState = () => {
    try {
        const savedState = JSON.parse(localStorage.getItem('quranPlayerState'));
        if (savedState && savedState.queue?.length > 0) {
            queue = savedState.queue;
            currentQueueIndex = savedState.currentQueueIndex ?? -1;
            repeatMode = savedState.repeatMode || 'off';
            isShuffled = savedState.isShuffled || false;
            playbackSpeed.value = savedState.speed || 1;
            audioPlayer.playbackRate = savedState.speed || 1;
            
            if (currentQueueIndex !== -1) {
                 const { reciter, moshaf, surah } = queue[currentQueueIndex];
                 const surahNumber = padSurahNumber(surah.id);
                 audioPlayer.src = `${withSlash(moshaf.server)}${surahNumber}.mp3`;
                 
                 audioPlayer.addEventListener('loadedmetadata', () => {
                     if(savedState.currentTime) audioPlayer.currentTime = savedState.currentTime;
                 }, { once: true });

                 nowPlaying.innerHTML = `
                     <p class="font-bold text-primary truncate" title="${surah.name}">${surah.name}</p>
                     <p class="text-sm text-gray-600 dark:text-gray-400 truncate" title="${reciter.name} - ${moshaf.name}">${reciter.name} - ${moshaf.name}</p>
                 `;
                 playerContainer.style.transform = 'translateY(0)';
            }
            
            if(isShuffled) {
                shuffleBtnPlayer.classList.add('text-primary');
                shuffleBtnPlayer.setAttribute('aria-pressed', 'true');
            }
            
            repeatBtn.textContent = 'ØªÙƒØ±Ø§Ø±';
            repeatBtn.classList.remove('text-primary');
            if(repeatMode === 'all') {
                repeatBtn.classList.add('text-primary');
                repeatBtn.textContent = 'ØªÙƒØ±Ø§Ø± Ø§Ù„ÙƒÙ„';
            } else if (repeatMode === 'one') {
                repeatBtn.classList.add('text-primary');
                repeatBtn.textContent = 'ØªÙƒØ±Ø§Ø± 1';
            }
            repeatBtn.setAttribute('aria-pressed', String(repeatMode !== 'off'));

            renderQueue();
        }
    } catch (e) {
        console.error("Failed to load saved state:", e);
        localStorage.removeItem('quranPlayerState');
    }
};

window.addEventListener('beforeunload', saveState);

// --- Audio Error Handling ---
audioPlayer.addEventListener('error', (e) => {
    console.error("Audio playback error:", e);
    showToast('ØªØ¹Ø°Ø± ØªØ´ØºÙŠÙ„ Ø§Ù„Ù…Ù‚Ø·Ø¹. ÙŠØªÙ… Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ù„Ù„ØªØ§Ù„ÙŠ.', 'error');
    setTimeout(playNext, 1000);
});

// --- Swipe Gestures for Queue ---
let touchStartY = null;
playerContainer.addEventListener('touchstart', (e) => {
    if (e.target.closest('#progress-bar-container')) return;
    touchStartY = e.touches[0].clientY;
});
playerContainer.addEventListener('touchend', (e) => {
    if (touchStartY == null) return;
    const dy = e.changedTouches[0].clientY - touchStartY;
    if (dy < -50) playerContainer.classList.add('queue-open');
    if (dy > 50)  playerContainer.classList.remove('queue-open');
    touchStartY = null;
});


// --- Initial Load ---
const loadReciters = async () => {
    currentFetchCtrl?.abort();
    currentFetchCtrl = new AbortController();
    const { signal } = currentFetchCtrl;

    showLoader(true);
    const lang = languageSelect.value || 'ar';
    const riwaya = riwayaSelect.value;
    const sura = surahSelect.value;
    let query = `reciters?language=${lang}${riwaya ? `&rewaya=${riwaya}` : ''}${sura ? `&sura=${sura}` : ''}`;
    const data = await fetchData(query, signal);

    if (signal.aborted) return;

    if(data) {
        allReciters = data.reciters || [];
        renderReciters();
    }
    showLoader(false);
};

const loadInitialData = async () => {
    showLoader(true);
    applyTheme();
    loadFavorites();
    const langCode = localStorage.getItem('quranLang') || 'ar';
    
    const initialCtrl = new AbortController();
    const { signal } = initialCtrl;

    const [languages, riwayat, suwar, recitersData] = await Promise.all([
        fetchData('languages', signal),
        fetchData(`riwayat?language=${langCode}`, signal),
        fetchData(`suwar?language=${langCode}`, signal),
        fetchData(`reciters?language=${langCode}`, signal)
    ]);
    
    if (signal.aborted) return;

    if (languages) renderLanguages(languages);
    if (riwayat) renderRiwayat(riwayat);
    if (suwar) renderSurahs(suwar);
    if (recitersData) {
        allReciters = recitersData.reciters || [];
        renderReciters();
    }
    
    showLoader(false);
    loadState();
    renderQueue();
    setTimeout(applyDeepLink, 500); // Wait for data to be ready
};

languageSelect.addEventListener('change', () => {
    localStorage.setItem('quranLang', languageSelect.value);
    loadInitialData();
});
riwayaSelect.addEventListener('change', loadReciters);
surahSelect.addEventListener('change', loadReciters);
searchReciterInput.addEventListener('input', debounce(renderReciters, 250));

document.addEventListener('DOMContentLoaded', loadInitialData);
